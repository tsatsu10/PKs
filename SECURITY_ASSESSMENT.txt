================================================================================
PKS — SECURITY ASSESSMENT
================================================================================
Date: February 2025
Scope: Frontend (React/Vite), Supabase (Auth, DB, RLS, Edge Functions), Backend (optional Node)

================================================================================
1. EXECUTIVE SUMMARY
================================================================================

- Critical: Webhook-deliver edge function was fetching all integrations (no user_id filter). FIXED: now filters by user.id.
- High: HTML export used unsanitized markdown-to-HTML (XSS risk). FIXED: DOMPurify added; markdownToHtml() sanitizes output.
- Dependencies: 7 npm vulnerabilities (ReDoS in ESLint/minimatch chain); dev-only, no fix available; low runtime impact.
- RLS: Consistently applied on all user-scoped tables; SECURITY DEFINER functions use auth.uid().
- Secrets: No secrets in repo; .env gitignored; Edge Functions use Deno.env.get for OPENAI_API_KEY and Supabase keys.

================================================================================
2. AUTHENTICATION & AUTHORIZATION
================================================================================

2.1 Authentication
- Supabase Auth (email/password). No service_role or anon key misuse in frontend.
- Frontend uses only VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY (public anon key is acceptable; RLS enforces access).
- Protected routes: ProtectedRoute.jsx redirects unauthenticated users to /login; session from Supabase.

2.2 Authorization (RLS)
- Row Level Security enabled on: users, knowledge_objects, knowledge_object_versions, knowledge_object_domains,
  knowledge_object_tags, link_edges, domains, tags, files, knowledge_object_files, prompt_templates, prompt_runs,
  share_permissions, audit_logs, notifications, templates, integrations, import_items, export_jobs, export_job_items,
  journal_entries, paste_bin. Storage bucket pks-files has RLS (insert/select/delete own).
- Policies are user_id = auth.uid() or share_permissions for shared access where applicable.
- resolve_user_id_by_email: SECURITY DEFINER, returns user id by email; used for sharing. No exposure of sensitive data.

2.3 Edge Functions
- run-prompt: Requires Authorization header; validates JWT with supabase.auth.getUser(token). Uses anon key + user JWT (RLS applies if DB were called). OPENAI_API_KEY from env only.
- webhook-deliver: Required Authorization; validates user. FIXED: now filters integrations by user_id so only the authenticated user's webhooks are triggered (was missing .eq("user_id", user.id)).

================================================================================
3. DATA & INPUT
================================================================================

3.1 SQL / Injection
- No raw SQL in frontend. All data access via Supabase client (.from(), .rpc()). RPCs use parameterized inputs (search_knowledge_objects, etc.).

3.2 XSS
- Export HTML: buildExportHtml() uses escapeHtml() for title, summary, tags, etc. Content was passed through markdownToHtml() without sanitization. FIXED: DOMPurify.sanitize() applied to markdown output with an allowlist of safe tags (no script, iframe, etc.).
- BlockNote/Markdown in UI: Rendered in controlled components; export path is the main risk and is now sanitized.

3.3 CSRF
- Supabase uses JWT in Authorization header; same-origin or CORS. No cookie-based auth, so classic CSRF is reduced. Edge Functions require explicit Authorization header.

================================================================================
4. SECRETS & CONFIGURATION
================================================================================

- .gitignore: .env, .env.local, .env.*.local. No secrets committed.
- Frontend: Only VITE_* vars (VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, VITE_API_URL). These are baked into build; anon key is public by design.
- Edge Functions: OPENAI_API_KEY, SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY from Deno.env (Supabase secrets).
- Backend (optional): PORT, FRONTEND_URL, DATABASE_URL, JWT_SECRET from process.env. Not used by default (app uses Supabase Auth).

================================================================================
5. DEPENDENCIES (npm audit)
================================================================================

- 7 vulnerabilities: 3 moderate, 4 high. All in devDependencies (eslint, @eslint/*, minimatch, ajv). ReDoS and similar; not in production runtime.
- No fix available for some (e.g. ajv, minimatch). Mitigation: run npm audit periodically; consider upgrading or replacing ESLint when fixes land.

================================================================================
6. RECOMMENDATIONS
================================================================================

1. Keep Edge Function secrets (OPENAI_API_KEY, SUPABASE_SERVICE_ROLE_KEY) only in Supabase Project Settings → Edge Functions → Secrets.
2. In production, ensure Supabase project has strong auth settings (email confirmation, rate limits, etc.).
3. Optional: Add rate limiting on run-prompt and webhook-deliver (e.g. per user) to avoid abuse.
4. resolve_user_id_by_email: Consider rate limiting or abuse detection (email enumeration). Low risk for trusted users.
5. Continue to run npm audit and update dependencies when fixes are available for devDependency chains.

================================================================================
7. FIXES APPLIED IN THIS ASSESSMENT
================================================================================

1. webhook-deliver/index.ts: Added .eq("user_id", user.id) when querying integrations so only the authenticated user's webhooks receive events.
2. frontend/src/lib/markdown.js: Sanitize markdown-to-HTML output with DOMPurify (allowlist of safe tags) to prevent XSS in HTML export and print.
3. Added SECURITY_ASSESSMENT.txt (this file) for tracking.

================================================================================
